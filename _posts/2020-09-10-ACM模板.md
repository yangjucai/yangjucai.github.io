---
layout: post
title: ACM板子
categories: [ACM]
description: ACM刷题模板
keywords: ACM，机试
---

## 2、图论

- 邻接矩阵表示法：

<details><summary><font color='green'>      　　　　     -------->see code<--------</font></summary>
<pre><code>
class MatGraph {
public:
    set<int> V;//顶点表
    int E[maxn][maxn];//边表
    int vn, en;//当前图的顶点数和边数
    MatGraph() {
        for (int i = 0; i < maxn; i++) {
            for (int j = 0; j < maxn; j++)
            {
                E[i][j] = -1;
            }
        }
        vn = en = 0;
    };
    void addV(int newV) {
        if (V.find(newV) == V.end()) {
            V.insert(newV);
            vn++;
        }
    };
    void addE(int begin, int end, int weight) {
        if (E[begin][end] == -1) {
            en++;
        }
        E[begin][end] = E[end][begin] = weight;
    };
};
</details>





邻接表法：

<details><summary><font color='green'> 　　　　 -------->see code<--------</font></summary>
<pre><code>
typedef struct {
    int tovex;//该边指向的顶点的位置
    edgeNode* next;//下一条边的指针
}edgeNode;
//
typedef struct {
    int data;//定点信息
    edgeNode* first;//指向第一条依附于该定点的边的指针
}vexNode,AdjList[maxn];
//
typedef struct {
    AdjList vex; //定点表（链表的头）
    int vexnum, edgenum;//当前图的顶点数和边数
}AdjGraph;
</code></pre>
</details>

- 邻接表法：

<details><summary><font color='green'> 　　　　 -------->see code<--------</font></summary>
<pre><code>
typedef struct {
    int tovex;//该边指向的顶点的位置
    edgeNode* next;//下一条边的指针
}edgeNode;
//
typedef struct {
    int data;//定点信息
    edgeNode* first;//指向第一条依附于该定点的边的指针
}vexNode,AdjList[maxn];
//
typedef struct {
    AdjList vex; //定点表（链表的头）
    int vexnum, edgenum;//当前图的顶点数和边数
}AdjGraph;
</code></pre>
</details>

