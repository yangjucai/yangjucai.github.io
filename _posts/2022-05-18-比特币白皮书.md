---
layout: post
title: 比特币白皮书译文
categories: [paper translation, cryptocurrency]
description: bitcoin white paper
keywords: bitcoin, white paper
---

  <h2 align="center">比特币：一个端到端的电子现金系统</h2>

<center>Satoshi Nakamoto</center>
<center>satoshin@gmx.com</center>
<center>www.bitcoin.org</center>
<p align="right">
    ------------------JC 译
</p>


**摘要**。 一个纯粹的端到端版本的电子现金允许线上付款从一个地方传送到另一个地方而不通过任何一个金融机构。数字签名提供了部分解决方法，但如果仍然需要一个可信的第三方来阻止重复付款，那么它主要的优势就丧失了。我们提出了一个使用端到端网络来解决重复付款问题的方案。该网络通过把交易哈希映射到一个持续存在的基于哈希工作量证明的链上，从而形成一个不重新进行工作量证明就不能被改变的记录，来给交易打时间戳。最大的链不仅是事件发生顺序的证明，也是他来自最大CPU算力池的证明。只要CPU算力的主体被那些不会去攻击网络的节点所控制，这些节点就会产生最长的链同时赶超攻击者。这种网络本身需要最小的结构。消息被最大程度的广播出去，节点可以随意离开和加入网络，接受最长的工作量证明链作为节点离开是发生的事件的证明。



#### 1. 	简介。

互联网商业几乎仅仅依赖金融机构作为可信的第三方来推进电子支付。尽管这个系统可以很好的服务于大多数交易，但它依然具有基于信任模型的固有的缺点。完全不可逆的交易是不太可能的，因为金融机构不可避免地要调节交易纠纷。调解纠纷的费用提高了交易的费用，限制了最小交易的实际规模，排除了随意进行小型交易的可能，并且失去对不可逆服务的不可逆支付的能力会带来更大的开销。有了可逆的可能性，对信任的需求就会扩大。商人必须对他们的客户非常谨慎，纠缠客户以获取更多他们并不不要的信息。一定程度的欺诈被认为是不可避免地。这些开销和支付不确定性可以通过个人使用实体货币来避免，但是不存在通过不依赖于可信第三方的沟通渠道完成支付的机制。

​		我们需要的是一个基于密码证明而不是基于信任的电子支付系统，它允许任何自愿交易的两方相互交易而不需要可信的第三方。计算上不可逆转的交易可以保护卖家免受欺诈，常规的托管机构可以很容易地保护买家。在这篇论文中，我们针对重复付款问题，提出一种使用端到端分布式时间戳服务器来生成交易时间顺序的计算证明的解决方法。只要诚实节点集体控制的CPU算力比攻击节点的同谋组多，这个系统就是安全的。



#### 2.	交易

我们定义一个电子货币是一个链的数字签名。每个拥有者通过对之前交易的哈希值和下一个拥有者的公钥进行数字签名并且把它们加到币的末尾将币转给下一个人。领款人可以通过验证签名来验证该链的所有权。

![](https://cdn.jsdelivr.net/gh/yangjucai/yangjucai.github.io@main/images/postspostsimage-20220519202033553.png)

​		当然，问题是领款人不能验证其中一个拥有者没有重复使用该币。一种常见的解决方案是引入可信的中央权威机构或造币厂，来检查每笔交易是否有重复支出。每次交易后，该币必须退回到造币厂来发行一个新币，并且直接从造币厂发行的币被认为是没有被重复支付的。这种解决方法的问题是整个货币体系的命运取决于运营造币厂的公司，而每笔交易都必须经过他们，就像银行一样。

​		我们需要一种方法让收款人知道之前的持有者没有对任何早先的交易签名。对于我们的目的而言，最早的交易起作用，所以我们不关心后续重复支付的可能。确定一个叫已不存在的唯一方法是了解所有的交易。在基于造币厂的模型中，造币厂了解所有的交易并且决定哪一个最先到达。为了在没有可信第三方的基础上完成这一点，交易必须公开发布，并且我们需要一个系统让参与者认同一个唯一的他们收到的交易的历史顺序。收款方需要在每个交易的时间点上，绝大多数的节点同意他是第一个到达的证明。



#### 3.	时间戳服务器

我们提出的这个方案开始于一个时间戳服务器。一个时间戳服务器的工作是把一个区块的哈希值签名并广播这个哈希值，就像在报纸或Usenet 帖子一样。显然，时间戳证明了为了进入哈希，数据必须在这个时间存在。每个时间戳包含了在它的哈希中的之前的时间戳，和每个用于增强之前时间戳的额外时间戳一起，形成一条链。

![image-20220520124907437](https://cdn.jsdelivr.net/gh/yangjucai/yangjucai.github.io@main/images/postsimage-20220520124907437.png)

#### 4.	工作量证明

为了在端到端基础上实现一个分布式时间戳服务器，我们将需要一个类似于由Adam Back提出的Hashcash（一种工作量证明系统），而不是报纸或Usenet帖子。工作量证明涉及在哈希映射时扫描一个值，比如对于SHA-256哈希算法，哈希映射从一个比特位全零的数开始。所需要的平均工作量是零位数所需要工作量的指数级并且可以通个执行一个单一的哈希算法验证。

​		在我们的时间戳网络中，我们通过增加在区块中递增一个随机数直到找到满足区块哈希所需的零位的数。一旦CPU的工作量满足了工作量证明的要求，不重做工作量证明区块就不能被改变。一旦后续的区块链接到它后面，改变这个区块的工作将包括重做该区块后面所有的区块的工作量证明。
​							![image-20220521125536350](https://cdn.jsdelivr.net/gh/yangjucai/yangjucai.github.io@main/images/postsimage-20220521125536350.png)

​		工作量证明也解决了在做多数人决策时确定表示的问题。如果多数票是基于一个IP一票，他可能被任何能够获取大量IP的人破坏，工作量证明本质上是一个CPU一票。多数票决策用最长的链表示，该链投入了最多的工作量证明。如果大多数的CPU算力被诚实的节点控制，那么这个最诚实的链将会增长的最快并且超过任何竞争链。为了修改之前的区块，攻击者不得不重做该区块和所有它之后的区块的工作量证明并且赶上并超过最诚实节点的工作。我们之后将会展示，随着子区块的添加，较慢的攻击者赶上的概率呈指数下降。

​		为了弥补逐渐增长的硬件速度和随时间推移运行结点的不同兴趣，工作量证明的难度由一个变化的平均值决定，该平均值指明了每小时区块（产生）的平均数量。如果节点产生的太快，难度将会增加。

#### 5.	网络

运行网络的步骤如下：

1. 新的交易被广播给所有结点。

2. 每个节点把新的交易聚集到一个区块中。

3. 每个节点致力于为它的区块寻找一个困难的工作量证明。

4. 当一个节点找到一个工作量证明，它将其广播给所有结点。

5. 只有一个区块中的所有交易都是合法有效的并且没有先前支付过，节点才接受该区块。

6. 节点通过使用该被接受的链的哈希值作为之前的哈希值，生成该链中的下一个区块，来传播节点接受了这个区块。

​        节点总是把最长的链认为是正确的并且持续扩展它。如果两个节点同时广播不同的区块，其他的节点将会先收到一个或另一个。在这种情况下，节点会使用他们先收到的区块，但是会保存另一个分支以备它成为更长的链。当下一个工作量证明被发现的时候，这种纠缠的状态将会被打破，并且一个分支变得更长，工作在另一个分支上的节点将转到更长的分支上。

​		新的交易的广播不必要到达所有的节点。只要他们到达很多节点，他们就会很快进入一个块中。区块广播业能容忍被丢弃的消息。如果一个节点没有收到一个区块，它将在收到下一个区块并且意识到缺失了一个区块的时候请求它。

#### 6.	激励

按照惯例，一个区块的第一笔交易是开始了一个由区块创建者拥有的新币的特殊交易。这增加了节点支持网络的积极性，并且提供了一种分配加密货币进入流通的方式，因为没有中心化的机构发布这些币。这种稳定增加一定数量的新币和金矿矿工消耗资源资源来增加金进入流通相似。在我们这个场景中，消耗了CPU时间和电力。

​		

   

